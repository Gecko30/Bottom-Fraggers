package com.example.demo;

// TODO preset waves
// TODO change toggle waves setting to toggle incident, standing, reflected wave
// TODO fix lambda equation
// TODO fix scaling on graph, fix numbers that come off bottom of screen for y axis, fix x axis title.

import javafx.animation.*;
import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

public class Ui extends Application {
    static String menuPic, homePic, helpPic;
    static Color OMORI = Color.web("#6c0ffe");
    static Circle c;

    static ArrayList<Circle> standList = new ArrayList<>();
    static ArrayList<Circle> travelList = new ArrayList<>();
    static ArrayList<Circle> reTravelList = new ArrayList<>();

    static Newton.Timer timer;
    static Line vertGrid, horiGrid, xIndic, yIndic;
    static ArrayList<Line> hLineList = new ArrayList<>();
    static ArrayList<Line> vLineList = new ArrayList<>();
    static ArrayList<Line> xIndiList = new ArrayList<>();
    static ArrayList<Line> yIndiList = new ArrayList<>();
    static Text xL, yL;
    static ArrayList<Text> xLabelList = new ArrayList<>();
    static ArrayList<Text> yLabelList = new ArrayList<>();
    static int startPauseCounter, incidentCounter, reflectedCounter, standingCounter = 0;

    static double A, f, T, omega, lambda, k, waveLength, xPos, timeElapsed, timeWhenStopped, totalTimeWhenStopped;
    static int stringLength = 490;
    static double timeToReachEnd = 4.9;
    static double v = 100;

//    Ui(Stage travelWaveStage) {
//        start(travelWaveStage);
//    }

    @Override
    public void start(Stage stage) {
        Button playBtn = new Button("Play");
        Pane wavesPane = new Pane();
        wavesPane.setPrefWidth(960);
        wavesPane.setPrefHeight(384);

        /**
         * JSON file
         */
        JSONParser jsonParser = new JSONParser();
        try {
            Object o = jsonParser.parse(new FileReader(this.getClass().getClassLoader().getResource("index.json").getFile()));
            JSONObject jsonObject = (JSONObject) o;
            menuPic = (String) jsonObject.get("menuIcon");
            homePic = (String) jsonObject.get("homeIcon");
            helpPic = (String) jsonObject.get("newtonSecondStagePic");
        }
        catch (ParseException | IOException e) {
            e.printStackTrace();
        }

        /**
         * Setting up the Main Page
         */
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(10));

        /**
         * Navigation Button
         */
        //Pane for settings
        HBox nagivationHBox = new HBox(230);
        nagivationHBox.setPadding(new Insets(10, 5, 5, 5));
        Pane menuPane = new Pane();

        //Toggling the incident and reflect rays visibility
        Menu raysVis = new Menu("Toggle Wave(s)");
        MenuItem toggleIncident = new MenuItem("Incident");
        MenuItem toggleReflected = new MenuItem("Reflected");
        MenuItem toggleStanding = new MenuItem("Standing");
        raysVis.getItems().addAll(toggleIncident, toggleReflected, toggleStanding);

        //Toggling grid visibility
        Menu objects = new Menu("Toggle Grid");
        CheckMenuItem gridOn = new CheckMenuItem("On");
        CheckMenuItem gridOff = new CheckMenuItem("Off");
        gridOn.setSelected(true);
        objects.getItems().addAll(gridOn, gridOff);

        //Change themes
        Menu theme = new Menu("Theme");
        CheckMenuItem lightMode = new CheckMenuItem("Light Mode");
        CheckMenuItem darkMode = new CheckMenuItem("Dark Mode");
        lightMode.setSelected(true);
        theme.getItems().addAll(lightMode,darkMode);

        //Time effects
        Menu showForces = new Menu("Time");
        CheckMenuItem slowMotion = new CheckMenuItem("Slow Motion");
        CheckMenuItem normalMotion = new CheckMenuItem("Normal");
        CheckMenuItem fastMotion = new CheckMenuItem("Fast Motion");
        normalMotion.setSelected(true);
        showForces.getItems().addAll(slowMotion, normalMotion, fastMotion);

        //Help MenuItem
        MenuItem menuHelp = new MenuItem("Help");
        Pane helpPane = new Pane();
        helpPane.setPadding(new Insets(10));
        VBox theoVbox = new VBox(10);
        ScrollBar sb = new ScrollBar();
        sb.setOrientation(Orientation.VERTICAL);
        sb.setPrefHeight(650);
        sb.setLayoutX(985);
        sb.setMax(650);
        sb.valueProperty().addListener((observableValue, number, t1) -> theoVbox.setLayoutY(-t1.doubleValue()));
        theoVbox.setOnScroll(new EventHandler<ScrollEvent>() {
            @Override
            public void handle(ScrollEvent scrollEvent) {
                theoVbox.setTranslateX(theoVbox.getTranslateX() + scrollEvent.getDeltaX());
                theoVbox.setTranslateY(theoVbox.getTranslateY() + scrollEvent.getDeltaY());
            }
        });

        Text theoryTxt = new Text("""
                 Crash Course on Traveling Waves

                     In the settings of this simulation, you will find the option to switch between light and dark mode,
                     the option to toggle the visibility of the travelling and standing waves,\s

                     To interact with the Standing wave simulation, simply press ‘start’ after adjusting the values on
                     the three sliders. In this simulation, there are sliders for each of the following parameters:
                     amplitude, wave speed, and mode number. Adjusting these parameters will result in standing waves
                     being formed for a string fixed on both ends.

                 Amplitude [m]: the maximum displacement or distance moved by a point on a vibrating body or wave
                 measured from its equilibrium position. It is equal to one-half the length of the vibration path.
                 Wave Speed [m/s]: the distance the disturbance travels across a medium in a given amount of time. It can
                 be calculated by multiplying frequency with the wavelength of a wave.
                 Frequency [Hz]: the number of waves that pass a fixed point in a given amount of time. The hertz
                 measurement, abbreviated Hz, is the number of waves that pass by per second.

                 It is possible to derive the wavelength, the distance between two successive crests or troughs (the
                 highest point of a wave and the lowest point of a wave respectively) from wave speed through the
                 formula:


                 Pictured below are visual representations of two travelling waves (green and blue,) that form a standing
                 wave (red).

                """);

        theoryTxt.setFont(Font.font("Consolas", FontWeight.NORMAL, FontPosture.REGULAR, 14));
        ImageView wavesEg = new ImageView(new Image("https://www.siliconera.com/wp-content/uploads/2020/03/xbc-de-16.jpg"));
        wavesEg.setFitWidth(990);
        wavesEg.setFitHeight(640);

        Text theoryTxt2 = new Text("""
                 What are standing waves and how are they created?

                     First, consider that waves always originate from some sort of event or disturbance. When two waves
                     with the same amplitude and frequency move in opposite directions, they will respect the
                     superposition principle and create what is known as an interference pattern. To elaborate, these
                     two linear waves will either be added together or cancelled out.

                     Interestingly enough, you might have even come across this phenomena without realising it yourself:
                     interference patterns are so common to our daily lives, and can be produced by waves in the water,
                     sound waves, or even light waves.

                     Should you make the choice to further explore the concepts related to waves, a great starting point
                     would be to consult these interesting articles written by Stephen Cohen (on his website, The
                     Engineer’s Pulse, under the “For Physics Students” section:

                """);

        theoryTxt2.setFont(Font.font("Consolas", FontWeight.NORMAL, FontPosture.REGULAR, 14));

        Text theoEqn = new Text("""
                 Standing Wave:     Traveling Wave:
                 Wave Speed:    Wave Number:
                 Angular Frequency: 
                 
                 Where:
                    x: a particle's
                    y: 
                    k: 
                    A: 
                    ω: 
                """);
        theoEqn.setFont(Font.font("Consolas", FontWeight.NORMAL, FontPosture.REGULAR, 14));

        theoVbox.getChildren().addAll(theoryTxt, wavesEg, theoryTxt2, theoEqn);
        helpPane.getChildren().addAll(theoVbox, sb);
        Scene theoryScene = new Scene(helpPane, 1000, 650);
        Stage secondaryStage = new Stage();
        secondaryStage.setTitle("Loss");
        secondaryStage.setResizable(false);
        secondaryStage.setScene(theoryScene);
        menuHelp.setOnAction(actionEvent -> secondaryStage.show());

        //Additional Settings
        MenuItem exitProgram = new MenuItem("Exit Program");
        MenuButton menuBtn = new MenuButton("Menu", null, raysVis,theme, objects, showForces, menuHelp, exitProgram);
        Image menuIcon = new Image(menuPic);
        ImageView menuView = new ImageView(menuIcon);
        menuView.setPreserveRatio(true);
        menuView.setFitHeight(25);
        menuBtn.setGraphic(menuView);
        menuBtn.setId("navigation");
        menuPane.getChildren().addAll(menuBtn);

        //Menu Settings
        Image homeIcon = new Image(homePic);
        ImageView homeView = new ImageView(homeIcon);
        homeView.setPreserveRatio(true);
        homeView.setFitHeight(80);
        Button homeBtn = new Button();
        homeBtn.setGraphic(homeView);
        homeBtn.setId("navigation");

        //Home Button settings
        Label warning = new Label();
        warning.setId("warning");
        warning.setVisible(false);
        nagivationHBox.getChildren().addAll(homeBtn,warning, menuPane);
        nagivationHBox.setAlignment(Pos.CENTER);

        //The Top Buttons
        VBox controls = new VBox(20);
        root.setTop(controls);
        HBox menuCtrl = new HBox();
        menuCtrl.getChildren().add(nagivationHBox);
        controls.getChildren().add(menuCtrl);

        //The UI Controls
        HBox ui = new HBox(120);
        ui.setAlignment(Pos.CENTER);
        controls.getChildren().add(ui);

        /**
         * Sliders
         * Always make the waves "snap" (clear first and then implement new values)
         */
        HBox sliders = new HBox(100);

        //Frequency: "clear" the values (for a split second) then implementing the new value
        VBox freqVBox = new VBox(5);
        Text freqText = new Text("Frequency [Hz]");
        TextField freqTf = new TextField("0.00 Hz");
        freqTf.setAlignment(Pos.CENTER);
        freqTf.setEditable(false);
        Slider freqSldr = new Slider(0, 5, 0); //we're sorry mr cohen
        freqSldr.setShowTickLabels(true);
        freqSldr.setShowTickMarks(true);
        freqSldr.setMajorTickUnit(1);
        freqSldr.setMinorTickCount(4);

        freqSldr.valueProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number number, Number t1) {
                f = freqSldr.getValue();
                freqTf.setText(String.format("%.2f", freqSldr.getValue()) + " Hz");
                if (startPauseCounter > 0 && playBtn.getText() == "Play") {
                    for (Circle c : standList) {
                        double sinTing = Math.sin(k * (c.getCenterX() - 30));
                        double cosTing = Math.cos(omega * (totalTimeWhenStopped));
                        double eq = 2 * A * sinTing * cosTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                    for (Circle c : travelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) - (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                    for (Circle c : reTravelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) + (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                }
                T = 1 / f;
                omega = 2 * Math.PI * f;
                waveLength = v / f;
                k = (2 * Math.PI) / waveLength;
                timeToReachEnd = stringLength / v;
            }
        });
        freqVBox.getChildren().addAll(freqText,freqTf, freqSldr);

        //Wave Speed
        VBox wavSpdVBox = new VBox(5);
        Text wavSpdText = new Text("Wave Speed [cm/s]");
        TextField wavSpdTf = new TextField("0.00 cm/s");
        wavSpdTf.setAlignment(Pos.CENTER);
        wavSpdTf.setEditable(false);
        Slider wavSpdSldr = new Slider(0, 1000, 0);
        wavSpdSldr.setShowTickLabels(true);
        wavSpdSldr.setShowTickMarks(true);
        wavSpdSldr.setMajorTickUnit(100);
        wavSpdSldr.setMinorTickCount(4);

        wavSpdSldr.valueProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number number, Number t1) {
                v = wavSpdSldr.getValue();
                wavSpdTf.setText(String.format("%.2f", wavSpdSldr.getValue()) + " cm/s");
                if (startPauseCounter > 0 && playBtn.getText() == "Play") {
                    for (Circle c : standList) {
                        double sinTing = Math.sin(k * (c.getCenterX() - 30));
                        double cosTing = Math.cos(omega * (totalTimeWhenStopped));
                        double eq = 2 * A * sinTing * cosTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                    for (Circle c : travelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) - (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                    for (Circle c : reTravelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) + (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + eq);
                    }
                }
                T = 1 / f;
                omega = 2 * Math.PI * f;
                waveLength = v / f;
                k = (2 * Math.PI) / waveLength;
                timeToReachEnd = stringLength / v;
            }
        });
        wavSpdVBox.getChildren().addAll(wavSpdText,wavSpdTf,wavSpdSldr);

        //Amplitude (changing the slider keeps the amp at max (snap) then implement new value)
        VBox ampVBox = new VBox(5);
        Text ampText = new Text("Amplitude [cm]");
        TextField ampTf = new TextField("0.00 cm");
        ampTf.setAlignment(Pos.CENTER);
        ampTf.setEditable(false);
        Slider ampSldr = new Slider(0, 30, 0);
        ampSldr.setShowTickMarks(true);
        ampSldr.setShowTickLabels(true);
        ampSldr.setMajorTickUnit(5);
        ampSldr.setMinorTickCount(4);

        ampSldr.valueProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number number, Number t1) {
                A = ampSldr.getValue();
                ampTf.setText(String.format("%.2f", ampSldr.getValue()) + " cm");
                if (startPauseCounter > 0 && playBtn.getText() == "Play") {
                    for (Circle c : standList) {
                        double sinTing = Math.sin(k * (c.getCenterX() - 30));
                        double cosTing = Math.cos(omega * (totalTimeWhenStopped));
                        double eq = 2 * A * sinTing * cosTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                    }
                    for (Circle c : travelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) - (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                    }
                    for (Circle c : reTravelList) {
                        double sinTing = Math.sin((k * (c.getCenterX() - 30)) + (omega * (totalTimeWhenStopped)));
                        double eq = A * sinTing;
                        c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                    }
                }
                T = 1 / f;
                omega = 2 * Math.PI * f;
                waveLength = v / f;
                k = (2 * Math.PI) / waveLength;
                timeToReachEnd = stringLength / v;
            }
        });

        ampVBox.getChildren().addAll(ampText,ampTf,ampSldr);
        sliders.getChildren().addAll(freqVBox, wavSpdVBox, ampVBox);
        ui.getChildren().add(sliders);

        HBox actionData = new HBox(100);
        actionData.setAlignment(Pos.CENTER);
        controls.getChildren().add(actionData);

        /**
         * Legend
         */
        VBox legend = new VBox(5);
        HBox incidTraveLeg = new HBox(10);
        Line inciTravLine = new Line(0, 0, 10, 0);
        inciTravLine.setStroke(Color.CORNFLOWERBLUE);
        inciTravLine.setStrokeWidth(3);
        Text inciTravLegTxt = new Text("Incident Traveling Wave");
        incidTraveLeg.getChildren().addAll(inciTravLine, inciTravLegTxt);

        HBox refTravLeg = new HBox(10);
        Line refTravLine = new Line(0, 30, 10, 30);
        refTravLine.setStroke(Color.MAROON);
        refTravLine.setStrokeWidth(3);
        Text refTravLegTxt = new Text("Reflected Traveling Wave");
        refTravLeg.getChildren().addAll(refTravLine, refTravLegTxt);

        HBox standLeg = new HBox(10);
        Line standLine = new Line(0, 40, 10, 40);
        standLine.setStroke(Color.DARKMAGENTA);
        standLine.setStrokeWidth(3);
        Text standLegTxt = new Text("Standing Wave");
        standLeg.getChildren().addAll(standLine, standLegTxt);

        legend.getChildren().addAll(incidTraveLeg, refTravLeg, standLeg);
        actionData.getChildren().add(legend);

        /**
         * Start Button
         */
        Button btn3 = new Button("Help");
        btn3.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                System.out.println("What did the ocean say to the beach?\nNothing, it just waved.\n");
            }
        });
        actionData.getChildren().add(playBtn);

        /**
         * Extra Displayed Values
         */
        VBox exData = new VBox(5);
        Text coordinateTxt = new Text("Point Coordinates (x,y): ");
        Text periodTxt = new Text("Period: ");
        Text omegaTxt = new Text("Angular Frequency: ");
        Text lambdaTxt = new Text("Wavelength: ");
        Text kTxt = new Text("Wave Number: ");
        exData.getChildren().addAll(coordinateTxt,periodTxt, omegaTxt, lambdaTxt, kTxt);
        actionData.getChildren().add(exData);

        /**
         * Displaying the waves
         */

        /**
         * Setting up the grid
         */
        //Grid lines
        for(int i = 30; i <= wavesPane.getPrefHeight() - 20; i += 20) {
            horiGrid = new Line(10, i + 2, 970, i + 2);
            horiGrid.setStroke(Color.LIGHTGRAY);
            hLineList.add(horiGrid);
            wavesPane.getChildren().add(horiGrid);
        }

        for(int i = 10; i <= 990; i += 20) {
            vertGrid = new Line(i, 32, i, wavesPane.getPrefHeight() - 33);
            vertGrid.setStroke(Color.LIGHTGRAY);
            vLineList.add(vertGrid);
            wavesPane.getChildren().add(vertGrid);
        }

        /**
         * Toggle Grid
         */
        gridOn.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                for(Line l: hLineList) {
                    wavesPane.getChildren().add(l);
                }
                for(Line l: vLineList) {
                    wavesPane.getChildren().add(l);
                }
                gridOff.setSelected(false);
            }
        });

        gridOff.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                for(Line l: hLineList) {
                    wavesPane.getChildren().remove(l);
                }
                for(Line l: vLineList) {
                    wavesPane.getChildren().remove(l);
                }
                gridOn.setSelected(false);
            }
        });

        /**
         * Creating Axis Lines
         */
        Line xAxis = new Line();
        xAxis.setStartX(10);
        xAxis.setEndX(970);
        xAxis.setStartY(wavesPane.getPrefHeight() / 2);
        xAxis.setEndY(wavesPane.getPrefHeight() / 2);
        Text xAxisTitle = new Text("X-Position (cm)");
        xAxisTitle.setFont(Font.font("Consanas", FontWeight.BOLD, FontPosture.REGULAR, 14));
        xAxisTitle.setLayoutX(880);
        xAxisTitle.setLayoutY(xAxis.getStartY() + 40);

        Line yAxis = new Line();
        yAxis.setStartX(30);
        yAxis.setEndX(30);
        yAxis.setStartY(32);
        yAxis.setEndY(wavesPane.getPrefHeight() - 32);
        Text yAxisTitle = new Text("Y-Position (cm)");
        yAxisTitle.setFont(Font.font("Consanas", FontWeight.BOLD, FontPosture.REGULAR, 14));
        yAxisTitle.setLayoutX(0);
        yAxisTitle.setLayoutY(20);

        wavesPane.getChildren().addAll(xAxis, xAxisTitle, yAxis, yAxisTitle);

        //X-Axis indices
        for(int i = 40; i < 980; i += 20) {
            xIndic = new Line(i, xAxis.getStartY() - 5, i, xAxis.getStartY() + 5);
            xIndiList.add(xIndic);
            wavesPane.getChildren().add(xIndic);
        }
        for(int i = 120; i < 980; i += 100) {
            int actNb = i/2 - 10;
            xL = new Text("" + actNb);
            xL.setFont(Font.font("Consolas", FontWeight.BOLD, FontPosture.REGULAR, 11));
            xL.setLayoutX(i - 8);
            xL.setLayoutY(xAxis.getStartY() + 20);
            xLabelList.add(xL);
            wavesPane.getChildren().add(xL);
        }

        //Y-Axis indices
        for(int i = (int) wavesPane.getPrefHeight() - 30; i >= 20; i -= 20) {
            yIndic = new Line(yAxis.getStartX() - 5, i - 2, yAxis.getStartX() + 5, i - 2);
            yIndiList.add(yIndic);
            wavesPane.getChildren().add(yIndic);
        }
        for(int i = 380; i > 40; i -= 20) {
            int actNb = (int) ((i - xAxis.getStartY()) / 2);
            yL = new Text("" + (actNb * -1 + 14) / 2);
            yL.setFont(Font.font("Consanas", FontWeight.BOLD, FontPosture.REGULAR, 11));
            yL.setLayoutX(5);
            yL.setLayoutY(i - 24);
            yLabelList.add(yL);
            wavesPane.getChildren().add(yL);
        }

        /**
         * Creating the incident traveling wave
         */
        for(int i = 30; i <= 970; i++) {
            c = new Circle(i, wavesPane.getPrefHeight()/2, 2, Color.CORNFLOWERBLUE);
            travelList.add(c);
        }
        for(Circle c: travelList) {
            wavesPane.getChildren().add(c);
        }

        /**
         * Creating the reflected traveling wave
         */
        for(int i = 30; i <= 970; i++) {
            c = new Circle(i, wavesPane.getPrefHeight()/2, 2, Color.MAROON);
            reTravelList.add(c);
        }
        for(Circle c: reTravelList) {
            wavesPane.getChildren().add(c);
        }

        /**
         * Creating the standing wave
         */
        for(int i = 30; i <= 970; i++) {
            c = new Circle(i, wavesPane.getPrefHeight()/2, 3, Color.DARKMAGENTA);
            standList.add(c);
        }
        for(Circle c: standList) {
            wavesPane.getChildren().add(c);
        }

        /**
         * Change Theme
         */
        lightMode.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                root.setStyle("-fx-background-color: white");
                inciTravLine.setStroke(Color.CORNFLOWERBLUE);
                inciTravLegTxt.setFill(Color.BLACK);
                refTravLine.setStroke(Color.MAROON);
                refTravLegTxt.setFill(Color.BLACK);
                standLine.setStroke(Color.DARKMAGENTA);
                standLegTxt.setFill(Color.BLACK);
                coordinateTxt.setFill(Color.BLACK);
                periodTxt.setFill(Color.BLACK);
                omegaTxt.setFill(Color.BLACK);
                lambdaTxt.setFill(Color.BLACK);
                kTxt.setFill(Color.BLACK);
                xAxis.setStroke(Color.BLACK);
                xAxisTitle.setFill(Color.BLACK);
                yAxis.setStroke(Color.BLACK);
                yAxisTitle.setFill(Color.BLACK);
                for(Line l: xIndiList) {
                    l.setStroke(Color.BLACK);
                }
                for(Text t: xLabelList) {
                    t.setFill(Color.BLACK);
                }
                for(Line l: yIndiList) {
                    l.setStroke(Color.BLACK);
                }
                for(Text t: yLabelList) {
                    t.setFill(Color.BLACK);
                }
                for(Circle c: travelList) {
                    c.setStroke(Color.CORNFLOWERBLUE);
                }
                for(Circle c: reTravelList) {
                    c.setStroke(Color.MAROON);
                }
                for(Circle c: standList) {
                    c.setStroke(Color.DARKMAGENTA);
                }
                darkMode.setSelected(false);
            }
        });

        darkMode.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                root.setStyle("-fx-background-color: #303030");
                freqText.setFill(Color.WHITE);
                ampText.setFill(Color.WHITE);
                wavSpdText.setFill(Color.WHITE);
                inciTravLine.setStroke(Color.CYAN);
                inciTravLegTxt.setFill(Color.WHITE);
                refTravLine.setStroke(Color.ORANGERED);
                refTravLegTxt.setFill(Color.WHITE);
                standLine.setStroke(OMORI);
                standLegTxt.setFill(Color.WHITE);
                coordinateTxt.setFill(Color.WHITE);
                periodTxt.setFill(Color.WHITE);
                omegaTxt.setFill(Color.WHITE);
                lambdaTxt.setFill(Color.WHITE);
                kTxt.setFill(Color.WHITE);
                xAxis.setStroke(Color.WHITE);
                xAxisTitle.setFill(Color.WHITE);
                yAxis.setStroke(Color.WHITE);
                yAxisTitle.setFill(Color.WHITE);
                for(Line l: xIndiList) {
                    l.setStroke(Color.WHITE);
                }
                for(Text t: xLabelList) {
                    t.setFill(Color.WHITE);
                }
                for(Line l: yIndiList) {
                    l.setStroke(Color.WHITE);
                }
                for(Text t: yLabelList) {
                    t.setFill(Color.WHITE);
                }
                for(Circle c: travelList) {
                    c.setStroke(Color.CYAN);
                }
                for(Circle c: reTravelList) {
                    c.setStroke(Color.ORANGERED);
                }
                for(Circle c: standList) {
                    c.setStroke(OMORI);
                }
                lightMode.setSelected(false);
            }
        });

        /**
         * Toggle Wave Visibility
         */

        toggleIncident.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                incidentCounter += 1;
                if (incidentCounter % 2 == 1) {
                    for(Circle c: travelList) {
                        wavesPane.getChildren().remove(c);
                    }
                }

                if (incidentCounter % 2 == 0) {
                    for(Circle c: travelList) {
                        wavesPane.getChildren().add(c);
                    }
                }
            }
        });

        toggleReflected.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                reflectedCounter += 1;
                if (reflectedCounter % 2 == 1) {
                    for(Circle c: reTravelList) {
                        wavesPane.getChildren().remove(c);
                    }
                }

                if (reflectedCounter % 2 == 0) {
                    for(Circle c: reTravelList) {
                        wavesPane.getChildren().add(c);
                    }
                }
            }
        });

        toggleStanding.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                standingCounter += 1;
                if (standingCounter % 2 == 1) {
                    for(Circle c: standList) {
                        wavesPane.getChildren().remove(c);
                    }
                }

                if (standingCounter % 2 == 0) {
                    for(Circle c: standList) {
                        wavesPane.getChildren().add(c);
                    }
                }
            }
        });

        /**
        * Fast, Slow, & Normal motion speeds
        */

        normalMotion.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                slowMotion.setSelected(false);
                fastMotion.setSelected(false);
            }
        });

        fastMotion.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                slowMotion.setSelected(false);
                normalMotion.setSelected(false);
            }
        });

        slowMotion.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent actionEvent) {
                fastMotion.setSelected(false);
                normalMotion.setSelected(false);
            }
        });

        /**
         * Equations and AnimationTimer
         */
        AnimationTimer animateTimer = new AnimationTimer() {
            @Override
            public void handle(long l) {

                T = 1 / f;
                omega = 2 * Math.PI * f;
                lambda = v / f;
                k = (2 * Math.PI) / lambda;

                periodTxt.setText("Period: " + String.format("%.2f", T) + " seconds");
                omegaTxt.setText("Angular Frequency: " + String.format("%.2f", omega) + " rad/s");
                lambdaTxt.setText("Wavelength: " + String.format("%.2f", lambda) + " cm"); // not accurate
                kTxt.setText("Wave Number: " + String.format("%.2f", k) + " rad/cm");

                if(normalMotion.isSelected()) {
                    timeElapsed = timer.elapsed();
                }
                if(slowMotion.isSelected()) {
                    timeElapsed = timer.elapsed() / 10;
                }
                if(fastMotion.isSelected()) {
                    timeElapsed = timer.elapsed() * 10;
                }
                for (Circle c : standList) {
                    double sinTing = Math.sin(k * (c.getCenterX() - 30));
                    double cosTing = Math.cos(omega * (timeElapsed + totalTimeWhenStopped));
                    double eq = 2 * A * sinTing * cosTing;
                    c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                }
                for (Circle c : travelList) {
                    double sinTing = Math.sin((k * (c.getCenterX() - 30)) - (omega * (timeElapsed
                            + totalTimeWhenStopped)));
                    double eq = A * sinTing;
                    c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                }
                for (Circle c : reTravelList) {
                    double sinTing = Math.sin((k * (c.getCenterX() - 30)) + (omega * (timeElapsed
                            + totalTimeWhenStopped)));
                    double eq = A * sinTing;
                    c.setCenterY(wavesPane.getPrefHeight()/2 + 2 * eq);
                }

            }
        };

        /**
         * Setting up the Pause / Play button
         */
        playBtn.setOnAction(actionEvent -> {

            startPauseCounter += 1;
            if (startPauseCounter % 2 == 1) {
                playBtn.setText("Pause");
                animateTimer.start();
                timer = new Newton.Timer();
            }

            if (startPauseCounter % 2 == 0) {
                playBtn.setText("Play");
                animateTimer.stop();
                timeWhenStopped = timer.elapsed();

                showCoordinates(coordinateTxt, standList);
                showCoordinates(coordinateTxt, travelList);
                showCoordinates(coordinateTxt, reTravelList);

                if (normalMotion.isSelected()) {
                    totalTimeWhenStopped += timeWhenStopped;

                }
                if (fastMotion.isSelected()) {
                    totalTimeWhenStopped += 10 * timeWhenStopped;

                }
                if (slowMotion.isSelected()) {
                    totalTimeWhenStopped += timeWhenStopped / 10;
                }

            }
        });

        root.setCenter(wavesPane);

        /**
         * Brining it all together
         */
        Scene scene = new Scene(root, 1000, 650);
        scene.getStylesheets().add(getClass().getResource("style.css").toExternalForm());
        stage.setTitle("Physics Learning Tool");
        stage.setResizable(false);
        stage.setScene(scene);
        stage.show();
    }

    private void showCoordinates(Text coordinateTxt, ArrayList<Circle> standList) {

        for (Circle c : standList) {

            c.setOnMouseEntered(mouseEvent -> {
                    coordinateTxt.setText("Point Coordinates (x,y): " + "(" + String.format("%.2f",
                            (c.getCenterX() * 4/7 - 120/7)) + ", " + String.format("%.2f",  (c.getCenterY() * -0.25 + 48)) + ")");
            });
            c.setOnMouseExited(mouseEvent -> {

                coordinateTxt.setText("Point Coordinates (x,y): ");
            });
        }
    }

    private void toggleWaves(){ //TODO move duplicate code here

    }

    public static void main(String[] args) {
        launch();
    }

}
